{
"version":3,
"file":"compile\\depack.js",
"lineCount":815,
"mappings":"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",
"sources":["node_modules/erte/src/diff.js","node_modules/erte/src/index.js","node_modules/fs/index.js","node_modules/path/index.js","node_modules/assert/index.js","node_modules/mismatch/src/index.js","node_modules/readline/index.js","node_modules/promto/src/index.js","node_modules/reloquent/src/lib/ask.js","node_modules/reloquent/src/lib/ask-questions.js","node_modules/reloquent/src/index.js","src/mask.js","src/lib/index.js","node_modules/os/index.js","node_modules/stream/index.js","node_modules/erotic/src/lib.js","node_modules/@artdeco/clean-stack/src/index.js","node_modules/erotic/src/callback.js","node_modules/erotic/src/index.js","node_modules/catchment/src/lib/index.js","node_modules/catchment/src/index.js","node_modules/assert-throws/src/index.js","node_modules/differently/src/index.js","node_modules/@zoroaster/deep-equal/src/index.js","node_modules/child_process/index.js","node_modules/spawncommand/src/index.js","node_modules/forkfeed/src/index.js","node_modules/@zoroaster/fork/src/lib/index.js","node_modules/@zoroaster/fork/src/lib/get-args.js","node_modules/@zoroaster/fork/src/index.js","src/lib/make-test.js","src/index.js","src/depack.js"],
"sourcesContent":["/**\n * @license diff package https://github.com/kpdecker/jsdiff\n * BSD License\n * Copyright (c) 2009-2015, Kevin Decker <kpdecker@gmail.com>\n */\nexport default class Diff {\n  diff(oldString, newString) {\n    let self = this\n\n    // Allow subclasses to massage the input prior to running\n    oldString = this.castInput(oldString)\n    newString = this.castInput(newString)\n\n    oldString = this.removeEmpty(this.tokenize(oldString))\n    newString = this.removeEmpty(this.tokenize(newString))\n\n    let newLen = newString.length, oldLen = oldString.length\n    let editLength = 1\n    let maxEditLength = newLen + oldLen\n    let bestPath = [{ newPos: -1, components: [] }]\n\n    // Seed editLength = 0, i.e. the content starts with the same values\n    let oldPos = this.extractCommon(bestPath[0], newString, oldString, 0)\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      // Identity per the equality and tokenizer\n      return [{ value: this.join(newString), count: newString.length }]\n    }\n\n    // Main worker method. checks all permutations of a given edit length for acceptance.\n    function execEditLength() {\n      for (let diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        let basePath\n        let addPath = bestPath[diagonalPath - 1],\n          removePath = bestPath[diagonalPath + 1],\n          oldPos = (removePath ? removePath.newPos : 0) - diagonalPath\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined\n        }\n\n        let canAdd = addPath && addPath.newPos + 1 < newLen,\n          canRemove = removePath && 0 <= oldPos && oldPos < oldLen\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined\n          continue\n        }\n\n        // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n        if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {\n          basePath = clonePath(removePath)\n          self.pushComponent(basePath.components, undefined, true)\n        } else {\n          basePath = addPath // No need to clone, we've pulled it from the list\n          basePath.newPos++\n          self.pushComponent(basePath.components, true, undefined)\n        }\n\n        oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath)\n\n        // If we have hit the end of both strings, then we are done\n        if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n          return buildValues(self, basePath.components, newString, oldString)\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath\n        }\n      }\n\n      editLength++\n    }\n\n    while (editLength <= maxEditLength) {\n      let ret = execEditLength()\n      if (ret) {\n        return ret\n      }\n    }\n  }\n\n  pushComponent(components, added, removed) {\n    let last = components[components.length - 1]\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = { count: last.count + 1, added: added, removed: removed }\n    } else {\n      components.push({ count: 1, added: added, removed: removed })\n    }\n  }\n  extractCommon(basePath, newString, oldString, diagonalPath) {\n    let newLen = newString.length,\n      oldLen = oldString.length,\n      newPos = basePath.newPos,\n      oldPos = newPos - diagonalPath,\n\n      commonCount = 0\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++\n      oldPos++\n      commonCount++\n    }\n\n    if (commonCount) {\n      basePath.components.push({ count: commonCount })\n    }\n\n    basePath.newPos = newPos\n    return oldPos\n  }\n\n  equals(left, right) {\n    return left === right\n  }\n  removeEmpty(array) {\n    let ret = []\n    for (let i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i])\n      }\n    }\n    return ret\n  }\n  castInput(value) {\n    return value\n  }\n  tokenize(value) {\n    return value.split('')\n  }\n  join(chars) {\n    return chars.join('')\n  }\n}\n\nfunction buildValues(diff, components, newString, oldString) {\n  let componentPos = 0,\n    componentLen = components.length,\n    newPos = 0,\n    oldPos = 0\n\n  for (; componentPos < componentLen; componentPos++) {\n    let component = components[componentPos]\n    if (!component.removed) {\n      if (!component.added) {\n        let value = newString.slice(newPos, newPos + component.count)\n        value = value.map(function(v, i) {\n          let oldValue = oldString[oldPos + i]\n          return oldValue.length > v.length ? oldValue : v\n        })\n\n        component.value = diff.join(value)\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count))\n      }\n      newPos += component.count\n\n      // Common case\n      if (!component.added) {\n        oldPos += component.count\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count))\n      oldPos += component.count\n\n      // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n      if (componentPos && components[componentPos - 1].added) {\n        let tmp = components[componentPos - 1]\n        components[componentPos - 1] = components[componentPos]\n        components[componentPos] = tmp\n      }\n    }\n  }\n\n  // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n  let lastComponent = components[componentLen - 1]\n  if (componentLen > 1\n      && typeof lastComponent.value === 'string'\n      && (lastComponent.added || lastComponent.removed)\n      && diff.equals('', lastComponent.value)) {\n    components[componentLen - 2].value += lastComponent.value\n    components.pop()\n  }\n\n  return components\n}\n\nfunction clonePath(path) {\n  return { newPos: path.newPos, components: path.components.slice(0) }\n}","import Diff from './diff'\n\nconst colors = {\n  'black': 30,\n  'red': 31,\n  'green': 32,\n  'yellow': 33,\n  'blue': 34,\n  'magenta': 35,\n  'cyan': 36,\n  'white': 37,\n  'grey': 90,\n}\n\nconst backgroundColors = {\n  'black': 40,\n  'red': 41,\n  'green': 42,\n  'yellow': 43,\n  'blue': 44,\n  'magenta': 45,\n  'cyan': 46,\n  'white': 47,\n}\n\n/**\n * Color the foreground.\n * @param {string} string The string to color.\n * @param {_erte.Color} color The color to apply.\n */\nexport function c(string, color) {\n  const cc = colors[color]\n  if (!cc) return string\n  return `\\x1b[${cc}m${string}\\x1b[0m`\n}\n\n/**\n * Color the background.\n * @param {string} string The string to color.\n * @param {_erte.Color} color The color to apply.\n */\nexport function b(string, color) {\n  const cc = backgroundColors[color]\n  if (!cc) return string\n  return `\\x1b[${cc}m${string}\\x1b[0m`\n}\n\n/**\n * Compares two strings and outputs a coloured version where strings don't match.\n * @param {string} source A string to compare.\n * @param {string} target Target string to compare with.\n * @returns {string} A string which uses shell-codes to highligh differences.\n */\nexport default function erte(source, target) {\n  const diff = new Diff()\n  const d = diff.diff(source, target)\n  const m = d.map(({ added, removed, value }) => {\n    let p\n    const s = value.split(' ')\n    if (added) {\n      p = s.map(t => {\n        return t.replace(/\\n$/mg, '\u23ce\\n')\n      }).map(t => c(t, 'green')).join(b(' ', 'green'))\n    } else if (removed) {\n      p = s.map(t => {\n        return t.replace(/\\n$/mg, '\u23ce\\n')\n      }).map(t => c(t, 'red')).join(b(' ', 'red'))\n    } else {\n      p = c(value, 'grey')\n    }\n    return p\n  })\n  const s = m.join('')\n  return s\n}\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_erte.Color} Color The color to apply.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {('black'|'red'|'green'|'yellow'|'blue'|'magenta'|'cyan'|'white'|'grey')} _erte.Color The color to apply.\n */\n","export default fs\nexport const {\n  ReadStream,\n  Stats,\n  WriteStream,\n  access,\n  accessSync,\n  appendFile,\n  appendFileSync,\n  chmod,\n  chmodSync,\n  chown,\n  chownSync,\n  close,\n  closeSync,\n  constants,\n  copyFile,\n  copyFileSync,\n  createReadStream,\n  createWriteStream,\n  exists,\n  existsSync,\n  fchmod,\n  fchmodSync,\n  fchown,\n  fchownSync,\n  fdatasync,\n  fdatasyncSync,\n  fstat,\n  fstatSync,\n  fsync,\n  fsyncSync,\n  ftruncate,\n  ftruncateSync,\n  futimes,\n  futimesSync,\n  lchmod,\n  lchmodSync,\n  lchown,\n  lchownSync,\n  link,\n  linkSync,\n  lstat,\n  lstatSync,\n  mkdir,\n  mkdirSync,\n  mkdtemp,\n  mkdtempSync,\n  open,\n  openSync,\n  read,\n  readFile,\n  readFileSync,\n  readSync,\n  readdir,\n  readdirSync,\n  readlink,\n  readlinkSync,\n  realpath,\n  realpathSync,\n  rename,\n  renameSync,\n  rmdir,\n  rmdirSync,\n  stat,\n  statSync,\n  symlink,\n  symlinkSync,\n  truncate,\n  truncateSync,\n  unlink,\n  unlinkSync,\n  unwatchFile,\n  utimes,\n  utimesSync,\n  watch,\n  watchFile,\n  write,\n  writeFile,\n  writeFileSync,\n  writeSync,\n} = fs","export default path\nexport const {\n  basename,\n  delimiter,\n  dirname,\n  extname,\n  format,\n  isAbsolute,\n  join,\n  normalize,\n  parse,\n  posix,\n  relative,\n  resolve,\n  sep,\n  win32,\n} = path","export default assert\nexport const {\n  AssertionError,\n  deepEqual,\n  deepStrictEqual,\n  doesNotThrow,\n  equal,\n  fail,\n  ifError,\n  notDeepEqual,\n  notDeepStrictEqual,\n  notEqual,\n  notStrictEqual,\n  ok,\n  strictEqual,\n  throws,\n} = assert","/**\n * Returns an array of captured groups of a regular expression as objects. Does not modify the `lastIndex` property of the regex.\n * @param {RegExp} re The regular expression used for matching.\n * @param {string} string String to find matches in.\n * @param {Array<string>} keys Keys to use to create an captured group object.\n * @param {boolean} addPositions Whether to include positions in the return.\n * @example\n *\n```js\nconst re = /(test) inside of a (string)(\\d)?/ig\nconst s = 'Test inside of a STRING1. TEST inside of a string.'\nconst keys = ['test', 'string', 'number']\nconst res = mismatch(re, s, keys)\n\n// result:\n[\n {\n   test: 'Test',\n   string: 'STRING',\n   number: '1',\n },\n {\n   test: 'TEST',\n   string: 'string',\n },\n]\n```\n */\nexport default function mismatch(re, string, keys, addPositions = false) {\n  /** @type {!Array<!Object<string, string>>} */\n  const m = []\n  string.replace(re, (match, ...args) => {\n    // remove position and input\n    const position = args[args.length - 2]\n    const start = addPositions ? { position } : {}\n    const p = args.slice(0, args.length - 2)\n    const o = p.reduce((acc, capturedGroup, i) => {\n      const key = keys[i]\n      if (!(key && capturedGroup !== undefined)) return acc\n      acc[key] = capturedGroup\n      return acc\n    }, start)\n    m.push(o)\n  })\n  return m\n}","export default readline\nexport const {\n  Interface,\n  clearLine,\n  clearScreenDown,\n  createInterface,\n  cursorTo,\n  emitKeypressEvents,\n  moveCursor,\n} = readline","function createTimeout(desc, timeout, cb) {\n  return setTimeout(() => {\n    const message = `${desc ? desc : 'Promise'} has timed out after ${timeout}ms`\n    const err = new Error(message)\n    err.stack = `Error: ${err.message}`\n    cb(err)\n  }, timeout)\n}\n\nfunction makeTimeoutPromise(desc, timeout) {\n  let to\n  const promise = new Promise((_, reject) => {\n    to = createTimeout(desc, timeout, reject)\n  })\n  return { timeout: to, promise }\n}\n\n/**\n * Create a promise which will be rejected after a timeout.\n * @param {!Promise<T>} promise A promise to race with\n * @param {number} timeout Timeout in ms after which to reject\n * @param {string} [desc] Description of a promise to be printed in error\n * @returns {!Promise<T>} A promise with a timeout\n * @template T\n */\nexport default async function createPromiseWithTimeout(promise, timeout, desc) {\n  if (!(promise instanceof Promise))\n    throw new Error('Promise expected')\n  if (!timeout)\n    throw new Error('Timeout must be a number')\n  if (timeout < 0)\n    throw new Error('Timeout cannot be negative')\n\n  const { promise: toPromise, timeout: to } = makeTimeoutPromise(desc, timeout)\n  try {\n    return await Promise.race([\n      promise,\n      toPromise,\n    ])\n  } finally {\n    clearTimeout(to)\n  }\n}","import { createInterface } from 'readline'\r\nimport promto from 'promto'\r\n\r\n/**\r\n * Ask user a question and wait for an answer.\r\n * @param {string} question Question to present to the user.\r\n * @param {{ password: (boolean| undefined), timeout: (number|undefined), input: (stream.Readable|NodeJS.ReadStream|undefined), output: (stream.Writable|NodeJS.WriteStream|undefined) }} options The options.\r\n */\r\nexport default function ask(question, options = {}) {\r\n  const {\r\n    timeout,\r\n    password = false,\r\n    output = process.stdout,\r\n    input = process.stdin,\r\n    ...rest\r\n  } = options\r\n  const rl = createInterface(/** @type {!readline.ReadLineOptions} */ ({\r\n    input,\r\n    output,\r\n    ...rest,\r\n  }))\r\n  if (password) {\r\n    /**\r\n     * Undocumented API.\r\n     * @type {!NodeJS.WriteStream}\r\n     * @suppress {checkTypes}\r\n     */\r\n    const o = rl['output']\r\n    /**\r\n     * Undocumented API.\r\n     * @suppress {checkTypes}\r\n     */\r\n    rl['_writeToOutput'] = (s) => {\r\n      if (['\\r\\n', '\\n', '\\r'].includes(s))\r\n        return o.write(s)\r\n\r\n      const v = s.split(question)\r\n      if (v.length == '2') {\r\n        o.write(question)\r\n        o.write('*'.repeat(v[1].length))\r\n      } else {\r\n        o.write('*')\r\n      }\r\n    }\r\n  }\r\n  const p = new Promise((r) => {\r\n    rl.question(question, r)\r\n  })\r\n\r\n  let promise\r\n  if (timeout) {\r\n    promise = promto(p, timeout, `reloquent: ${question}`)\r\n  } else {\r\n    promise = p\r\n  }\r\n  /**\r\n   * @suppress {checkTypes}\r\n   */\r\n  rl['promise'] = tryPromise(promise, rl)\r\n  return rl\r\n}\r\n\r\n/**\r\n * \r\n * @param {!Promise} promise \r\n * @param {!readline.Interface} rl \r\n */\r\nconst tryPromise = async (promise, rl) => {\r\n  try {\r\n    const res = await promise\r\n    return res\r\n  } finally {\r\n    rl.close()\r\n  }\r\n}\r\n\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('stream').Readable} stream.Readable\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('stream').Writable} stream.Writable\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('readline').ReadLineOptions} readline.ReadLineOptions\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('readline').Interface} readline.Interface\r\n */","import ask from './ask'\r\n\r\n/**\r\n * Color foreground with grey\r\n * @param {string} t\r\n */\r\nexport function c(t) {\r\n  return `\\x1b[90m${t}\\x1b[0m`\r\n}\r\n\r\n/**\r\n * Ask a set of questions.\r\n * @param {_reloquent.Questions} questions An object with questions as values\r\n * @param {number} [timeout] How long to wait before answer\r\n * @returns {!Promise<!Object<string, string>>} A promise where keys from the questions object are validated, assigned default values if required, and populated with answers. Validation function should either throw or return nothing, or throw an error.\r\n */\r\nexport default async function askQuestions(questions, timeout) {\r\n  if (typeof questions != 'object')\r\n    throw new Error('Please give an object with questions')\r\n\r\n  const keys = Object.keys(/** @type {!Object} */ (questions))\r\n  const res = await keys.reduce(async (acc, key) => {\r\n    const accRes = await acc\r\n\r\n    const value = questions[key]\r\n    /** @type {!_reloquent.Question} */\r\n    let question\r\n    switch (typeof value) {\r\n    case 'object':\r\n      question = /** @type {!_reloquent.Question} */ ({ ...value })\r\n      break\r\n    case 'string':\r\n      question = { text: value }\r\n      break\r\n    default:\r\n      throw new Error('A question must be a string or an object.')\r\n    }\r\n\r\n    question.text = `${question.text}${question.text.endsWith('?') ? '' : ':'} `\r\n\r\n    let defaultValue\r\n    let gotDefaultValue\r\n    if (question.defaultValue) {\r\n      defaultValue = question.defaultValue\r\n    }\r\n    if (question.getDefault) {\r\n      gotDefaultValue = await question.getDefault()\r\n    }\r\n\r\n    let dv = defaultValue || ''\r\n    if (defaultValue && gotDefaultValue && defaultValue != gotDefaultValue) {\r\n      dv = c(defaultValue)\r\n    } else if (defaultValue && defaultValue == gotDefaultValue) {\r\n      dv = ''\r\n    }\r\n    let gtd = gotDefaultValue || ''\r\n    const text = `${question.text}${dv ? `[${dv}] ` : ''}${gtd ? `[${gtd}] ` : ''}`\r\n    const { 'promise': promise } = ask(text, {\r\n      timeout,\r\n      password: question.password,\r\n      ...question,\r\n    })\r\n\r\n    const a = await promise\r\n    let answer = a || gotDefaultValue || question.defaultValue\r\n\r\n    if (typeof question.validation == 'function') {\r\n      question.validation(answer)\r\n    }\r\n    if (typeof question.postProcess == 'function') {\r\n      answer = await question.postProcess(answer)\r\n    }\r\n    return {\r\n      ...accRes,\r\n      [key]: answer,\r\n    }\r\n  }, {})\r\n\r\n  return res\r\n}\r\n\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('../..').Questions} _reloquent.Questions\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('../..').Question} _reloquent.Question\r\n */","import askQuestions from './lib/ask-questions'\r\n\r\n/**\r\n * @type {_reloquent.askQuestions}\r\n */\r\nexport default async function reloquent(questions, timeout) {\r\n  const res = await askQuestions(questions, timeout)\r\n  return res\r\n}\r\n\r\n/**\r\n * @type {_reloquent.askSingle}\r\n */\r\nexport async function askSingle(question, timeout) {\r\n  const { question: answer } = await askQuestions({ question }, timeout)\r\n  return answer\r\n}\r\n\r\n/**\r\n * @type {_reloquent.confirm}\r\n */\r\nexport async function confirm(question, options = {}) {\r\n  const {\r\n    defaultYes = true,\r\n    timeout,\r\n  } = options\r\n  const Q = typeof question == 'string' ? {\r\n    text: question,\r\n  } : question\r\n  const { text } = Q\r\n  const hasQ = text.endsWith('?')\r\n  const realText = `${hasQ ? text.replace(/\\?$/, '') : text} (y/n)${hasQ ? '?' : ''}`\r\n  const { question: answer } = await askQuestions({\r\n    question: {\r\n      defaultValue: defaultYes ? 'y' : 'n',\r\n      ...Q,\r\n      text: realText,\r\n    },\r\n  }, timeout)\r\n  return answer == 'y'\r\n}\r\n\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('..').ConfirmOptions} _reloquent.ConfirmOptions\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('..').Question} _reloquent.Question\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('..').Questions} _reloquent.Questions\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('../types').askSingle} _reloquent.askSingle\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('../types').confirm} _reloquent.confirm\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('../types').askQuestions} _reloquent.askQuestions\r\n */\r\n","import erte, { c } from 'erte'\r\nimport { equal } from 'assert'\r\nimport mismatch from 'mismatch'\r\nimport { readFileSync, writeFileSync } from 'fs'\r\nimport { askSingle, confirm } from 'reloquent'\r\nimport { splitWithPositions } from './lib'\r\nimport { EOL } from 'os'\r\n\r\n/**\r\n * A function to construct tests from a mask file.\r\n * @param {Object} conf\r\n * @param {string} conf.path Path to the mask file.\r\n * @param {!RegExp} [conf.splitRe] The regular expression to split the file by.\r\n * @param {!RegExp} [conf.propStartRe] The regular expression indicating the start of the property of the mask.\r\n * @param {!RegExp} [conf.propEndRe] The regular expression indicating the end of the property of the mask.\r\n */\r\nconst getTests = (conf) => {\r\n  const { path, propStartRe = /\\/\\*/, propEndRe = /\\/\\*\\*\\// } = conf\r\n  let { splitRe, jsonProps } = conf\r\n  if (!splitRe) {\r\n    splitRe = path.endsWith('.md') ?  /^## /gm : /^\\/\\/ /gm\r\n  }\r\n  let resultFile = readFileSync(path, 'utf8')\r\n  const mi = splitRe.exec(resultFile)\r\n  if (!mi) throw new Error(`${path} does not contain tests.`)\r\n  const preamble = resultFile.slice(0, mi.index).replace(/\\r?\\n\\r?\\n$/, '')\r\n  const mm = resultFile.slice(mi.index)\r\n  splitRe.lastIndex = 0\r\n  const t = splitWithPositions(mm, splitRe).filter(({ match }) => {\r\n    return match\r\n  })\r\n\r\n  const tests = t.map(({ match: test, position, separator }) => {\r\n    const [name, total] = split(test, EOL)\r\n    const [i, body] = splitWithRe(total, new RegExp(`\\\\r?\\\\n${propStartRe.source}`))\r\n    const bodyStartsAt = test.indexOf(body)\r\n    const input = i.replace(/\\r?\\n$/, '')\r\n\r\n    const offset = mi.index + bodyStartsAt + position + separator.length\r\n\r\n    const foundProps = mismatch(\r\n      new RegExp(`(${propStartRe.source} +(.+) +\\\\*\\\\/(\\\\r?\\\\n)?)([\\\\s\\\\S]*?)\\\\r?\\\\n${propEndRe.source}`, 'g'),\r\n      body,\r\n      ['preValue', 'key', 'newLine', 'value'], true,\r\n    )\r\n    /** @type {!Object<string, { start: number, length: number }>} */\r\n    const positions = {}\r\n\r\n    const expected = foundProps.reduce((acc, { 'preValue': preValue, 'key': key, 'newLine': newLine, 'value': value, 'position': p }) => {\r\n      const fullPosition = offset + p + preValue.length\r\n      positions[key] = { start: fullPosition, length: value.length }\r\n      const val = (!value && newLine) ? newLine : value\r\n      return {\r\n        ...acc,\r\n        [key]: val,\r\n      }\r\n    }, {})\r\n    return {\r\n      name,\r\n      input,\r\n      positions,\r\n      ...(preamble ? { 'preamble': preamble } : {}),\r\n      ...expected,\r\n    }\r\n  })\r\n\r\n  const lines = resultFile.split(EOL)\r\n  let lengthDifference = 0\r\n\r\n  /**\r\n   * A function to be called on error in a test.\r\n   * @param {string} name The name of the test.\r\n   * @param {!Object<string, { start: number, length: number }>} positions Positions of the properties.\r\n   * @param {!Error} error\r\n   * @throws {!Error} An error with a stack trace pointing at the line in the mask file.\r\n   */\r\n  const onError = async (name, positions, error) => {\r\n    const lineRe = new RegExp(`${splitRe.source}${name}\\r?$`)\r\n    const lineNumber = lines.reduce((acc, current, index) => {\r\n      if (acc) return acc // found\r\n      if (lineRe.test(current)) return index + 1\r\n      return acc\r\n    }, null)\r\n    const err = new Error(error.message)\r\n    // possibly also remember custom test stack later\r\n    const stack = makeStack(error.message, name, path, lineNumber)\r\n    err.stack = stack\r\n    if (error['property'] && error['actual']) {\r\n      const { 'property': property, 'actual': actual, 'expected': expected } = error\r\n      const handleUpdate = async ({\r\n        stdin,\r\n      } = {}) => {\r\n        // update in interactive mode\r\n        const position = positions[property]\r\n        if (!position) return false\r\n        const start = position.start + lengthDifference\r\n        let b = resultFile.slice(0, start)\r\n        if (position.length == 0) {\r\n          b += EOL\r\n        }\r\n        const a = resultFile.slice(start + position.length)\r\n        const act = jsonProps.includes(property) ? JSON.stringify(actual, null, 2) : actual\r\n        const newFile = `${b}${act}${a}`\r\n        console.error('Result does not match property \"%s\"', property)\r\n        console.error('  at %s (%s:%s:1)', c(name, 'blue'), path, lineNumber)\r\n        let shouldUpdate = false\r\n        const answer = await askSingle({\r\n          text: 'Show more (d), skip (s), or update (u): [u]',\r\n          input: stdin,\r\n        })\r\n        if (answer == 'd') {\r\n          console.log(c('Actual: ', 'blue'))\r\n          console.log(actual)\r\n          console.log(c('Expected: ', 'blue'))\r\n          console.log(expected)\r\n          shouldUpdate = await confirm('Update the result')\r\n        } else if (!answer || answer == 'u') {\r\n          shouldUpdate = true\r\n        }\r\n        if (!shouldUpdate) return false\r\n        lengthDifference += act.length - position.length\r\n        writeFileSync(path, newFile)\r\n        console.log('updated file', path)\r\n\r\n        resultFile = newFile\r\n\r\n        return true\r\n      }\r\n      err['handleUpdate'] = handleUpdate\r\n    }\r\n    throw err\r\n  }\r\n  const testsWithOnError = tests.map(({ name, positions, ...rest }) => {\r\n    const boundOnError = onError.bind(null, name, positions)\r\n    return {\r\n      ...rest,\r\n      name,\r\n      onError: boundOnError,\r\n    }\r\n  })\r\n  return testsWithOnError\r\n}\r\n\r\nconst makeStack = (message, name, path, lineNumber) => {\r\n  return `Error: ${message}${EOL}    at ${name} (${path}:${lineNumber}:1)`\r\n}\r\n\r\n/**\r\n * @returns {!Array<string>}\r\n */\r\nconst splitWithRe = (s, re) => {\r\n  const nl = s.search(re)\r\n  if (nl < 0) throw new Error(\r\n    `Could not process \"${s}\": propStart re ${re} returned -1`)\r\n  const first = s.substr(0, nl)\r\n  const second = s.substr(nl + 1)\r\n  return [first, second]\r\n}\r\n\r\n/**\r\n * @param {string} s The string to split.\r\n * @param {string} del The delimiter to split by\r\n * @returns {!Array<string>}\r\n */\r\nconst split = (s, del) => {\r\n  const nl = s.indexOf(del)\r\n  const first = s.substr(0, nl)\r\n  const second = s.substr(nl + del.length)\r\n  return [first, second]\r\n}\r\n\r\n/**\r\n * Asserts that the strings are equal, and prints a color message if they're not.\r\n */\r\n// eslint-disable-next-line no-console\r\nexport const assertExpected = (result, expected, log = console.log) => {\r\n  try {\r\n    equal(result, expected)\r\n  } catch (err) {\r\n    const e = erte(expected, result)\r\n    log(e)\r\n    err['property'] = 'expected'\r\n    throw err\r\n  }\r\n}\r\n\r\nexport default getTests","/**\r\n * Splits the string by regular expression and remembers positions.\r\n * @param {string} string\r\n * @param {!RegExp} re\r\n * @returns {!Array<{ position: number, separator: string, match: string }>}\r\n */\r\nexport const splitWithPositions = (string, re) => {\r\n  let tt = []\r\n  string.replace(re, (match, position) => {\r\n    tt.push({ position, separator: match })\r\n  })\r\n  tt = [{ position: 0, separator: '' }, ...tt]\r\n  const t = tt.reduce((acc, { position, separator }, i, arr) => {\r\n    const { length } = separator\r\n    const next = arr[i + 1]\r\n    if (!next) {\r\n      const r = string.slice(position + length)\r\n      acc.push({ position, separator, match: r })\r\n      return acc\r\n    }\r\n    const { position: nextPosition } = next\r\n    const r = string.slice(position + length, nextPosition)\r\n    acc.push({ position, separator, match: r })\r\n    return acc\r\n  }, [])\r\n  return t\r\n}\r\n\r\n/**\r\n * @param {!Object} props\r\n * @param {!Array<string>} jsonProps\r\n * @param {!Array<string>} jsProps\r\n */\r\nexport const parseProps = (props, jsonProps, jsProps) => {\r\n  const parsedRest = Object.keys(props).reduce((ac, k) => {\r\n    let val\r\n    const value = props[k]\r\n    if (jsonProps.includes(k)) {\r\n      try {\r\n        val = JSON.parse(value)\r\n      } catch (err) {\r\n        throw new Error(`Could not parse JSON property \"${k}\": ${err.message}.`)\r\n      }\r\n    } else if (jsProps.includes(k)) {\r\n      try {\r\n        val = eval(`(${value})`)\r\n      } catch(err) {\r\n        throw new Error(`Could not evaluate JS property \"${k}\": ${err.message}.`)\r\n      }\r\n    } else val = value\r\n    ac[k] = val\r\n    return ac\r\n  }, {})\r\n  return parsedRest\r\n}","export default os\nexport const {\n  EOL,\n  arch,\n  constants,\n  cpus,\n  endianness,\n  freemem,\n  homedir,\n  hostname,\n  loadavg,\n  networkInterfaces,\n  platform,\n  release,\n  tmpdir,\n  totalmem,\n  type,\n  uptime,\n  userInfo,\n} = os","export default stream\nexport const {\n  Duplex,\n  PassThrough,\n  Readable,\n  Stream,\n  Transform,\n  Writable,\n} = stream","const getLastItem = (array) => {\n  const item = array[array.length - 1]\n  return item\n}\nconst getItemsFrom = (array, from) => array.slice(from)\n\n/**\n * Get a segment of the stack string, defaults are from = 0 and oneLine = false.\n * @param {string} stack the stack string\n * @param {number} [from=0] index from which to slice from\n * @param {boolean} [oneLine=false] Whether just first line must be returned\n * @returns {string} A stack segment starting from the specified line.\n */\nexport const getStackSegment = (stack, from = 0, oneLine = false) => {\n  if (from === 0 && !oneLine) {\n    return stack\n  }\n  const splitStack = stack\n    .split('\\n', oneLine ? from + 1 : undefined)\n  if (oneLine) {\n    const line = getLastItem(splitStack)\n    return line\n  } else {\n    const items = getItemsFrom(splitStack, from)\n    return items.join('\\n')\n  }\n}\n\n/**\n * Get the stack trace part of when the erotic function was called. Disregards\n * first two lines.\n * @param {string} stack error's stack\n * @param {boolean} [transparent] trim the top line as well\n * @returns {string} A part of stack\n */\nexport const getEntryStack = (stack, transparent = false) => {\n  const stackSegment = getStackSegment(stack, 2 + (transparent ? 1 : 0))\n  return stackSegment\n}\n\n/**\n * Get stack line of where the callback was called.\n * @param {string} stack Stack string.\n * @returns {string} Stack line.\n */\nexport const getCalleeStackLine = (stack) => {\n  const calleeStackLine = getStackSegment(stack, 2, true)\n  return calleeStackLine\n}\n\nexport const getStackHeading = message => `Error: ${message}`\n\n/**\n * Extract caller from the function's `arguments`.\n * @param {Object} args arguments\n * @returns {!Function} The caller function from `arguments.callee.caller`.\n */\nexport const getCallerFromArguments = (args) => {\n  const { callee: { caller } } = args\n  return caller\n}","import { homedir } from 'os'\n\nconst extractPathRegex = /\\s+at.*(?:\\(|\\s)(.*)\\)?/\nconst pathRegex = /^(?:(?:(?:node|(?:internal\\/[\\w/]*|.*node_modules\\/(?:IGNORED_MODULES)\\/.*)?\\w+)\\.js:\\d+:\\d+)|native)/\n\nconst homeDir = homedir()\n\n/**\n * Remove internal Node.JS lines from the error stack traces.\n * @param {string} stack The error stack to update.\n * @param {!_cleanStack.Config} [options] Options for the program.\n * @param {boolean} [options.pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @param {!Array<string>} [options.ignoredModules=\"\uff3b'pirates'\uff3d\"] Which modules to ignore in the path. Default `\uff3b'pirates'\uff3d`.\n */\nconst cleanStack = (stack, options) => {\n  const {\n    pretty = false, ignoredModules = ['pirates'],\n  } = options || {}\n  const j = ignoredModules.join('|')\n  const re = new RegExp(pathRegex.source.replace('IGNORED_MODULES', j))\n\n  return stack.replace(/\\\\/g, '/')\n    .split('\\n')\n    .filter(x => {\n      const pathMatches = x.match(extractPathRegex)\n      if (pathMatches === null || !pathMatches[1]) {\n        return true\n      }\n\n      const match = pathMatches[1]\n\n      // Electron\n      if (match.includes('.app/Contents/Resources/electron.asar') ||\n        match.includes('.app/Contents/Resources/default_app.asar')) {\n        return false\n      }\n\n      return !re.test(match)\n    })\n    .filter(x => x.trim())\n    .map(x => {\n      if (pretty) {\n        return x.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, '~')))\n      }\n\n      return x\n    })\n    .join('\\n')\n}\n\nexport default cleanStack\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_cleanStack.Config} Config Options for the program.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _cleanStack.Config Options for the program.\n * @prop {boolean} [pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @prop {!Array<string>} [ignoredModules=\"\uff3b'pirates'\uff3d\"] Which modules to ignore in the path. Default `\uff3b'pirates'\uff3d`.\n */\n","import cleanStack from '@artdeco/clean-stack'\nimport {\n  getCallerFromArguments, getCalleeStackLine, getStackHeading,\n} from './lib'\n\n/**\n * Create a callback.\n * @param {!Function} entryCaller The function which was called at entry.\n * @param {string} entryStack The first line of the error stack to be returned\n * @param {boolean} [shadow=false] Print only entry stack.\n */\nexport function makeCallback(entryCaller, entryStack, shadow = false) {\n  /**\n   * This callback should be called when an asynchronous error occurred.\n   * @param {(string|Error)} messageOrError A message string or an _Error_ object at the point of actual error.\n   * @returns {Error} An error with the updated stack which includes the callee.\n   */\n  function cb(messageOrError) {\n    const caller = getCallerFromArguments(arguments)\n    const { stack: errorStack } = new Error()\n    const calleeStackLine = getCalleeStackLine(errorStack)\n    const isError = messageOrError instanceof Error\n    const message = isError ? messageOrError.message : messageOrError\n\n    const stackHeading = getStackHeading(message)\n    const entryHasCallee = caller !== null && entryCaller === caller\n    const stackMessage = [\n      stackHeading,\n      ...(entryHasCallee || shadow ? [entryStack] : [\n        calleeStackLine,\n        entryStack,\n      ]),\n    ].join('\\n')\n\n    const stack = cleanStack(stackMessage)\n    const properties = { message, stack }\n    const e = isError ? messageOrError : new Error()\n\n    return /** @type {Error} */ (Object.assign(/** @type {!Object} */ (e), properties))\n  }\n\n  return cb\n}","import {\n  getEntryStack, getCallerFromArguments,\n} from './lib'\nimport { makeCallback } from './callback'\n\n/**\n * Returns a function to create an error with a stack trace starting at the line in code when the call was made by the callee.\n * @param {boolean} [transparent] Pretend as if the call to the function lead to the error, without exposing any of the internal stack.\n */\nexport default function erotic(transparent) {\n  const { stack } = new Error()\n  const caller = getCallerFromArguments(arguments)\n  const entryStack = getEntryStack(stack, transparent)\n\n  return makeCallback(caller, entryStack, transparent)\n}","/**\n * Listens for the `error` event once so that when an error in _streamB_ is emitted, is is also emitted in the _streamA_.\n * @param {stream.Stream} streamA The stream that will emit an error once it's caught in the `streamB`.\n * @param {stream.Stream} streamB The stream from which the error originates.\n * @returns The stream the error is listened on, i.e., transparent to calling the `.once` method on that stream.\n */\nexport const pipeError = (streamA, streamB) => {\n  streamB\n    .once('error', e => {\n      streamA.emit('error', e)\n    })\n  return streamB\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Stream} stream.Stream\n */","import { Writable } from 'stream'\nimport erotic from 'erotic'\nimport cleanStack from '@artdeco/clean-stack'\nimport { pipeError } from './lib'\n\nfunction joinBufferData(array) {\n  return array.join('')\n}\n\n/**\n * A writable stream which collects incoming data into memory, and provides a promise to way for the stream to finish. The promise is resolved with joined chunks.\n */\nexport default class Catchment extends Writable {\n  /**\n   * Create a new catchment to pipe a readable stream into and collect all emitted data.\n   * @param {!_catchment.Options} [options] Options to pass to the `Writable` super constructor, and others shown below.\n   * @param {!stream.Readable} [options.rs] A readable stream to automatically pipe into the catchment. If an error occurs during reading of this stream, the catchment promise will be rejected with it.\n   * @param {boolean} [options.binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n   * @example\n   *\n   * import { createReadStream } from 'fs'\n   * import Catchment from 'catchment'\n   *\n   * const rs = createReadStream('file.txt')\n   * const { promise } = new Catchment({ rs })\n   * const res = await promise\n   */\n  constructor(options) {\n    const {\n      binary = false, rs = null, ...opts\n    } = options || {}\n    /** @suppress {missingProperties} */\n    const { er = erotic(true), proxyError } = options || {}\n    const wrap = (_, e) => er(e)\n    super(/** @type {!stream.WritableOptions} */ (opts))\n    this._caughtData = []\n    this._promise = new Promise((r, j) => {\n      this.on('finish', () => {\n        let d\n        if (binary) {\n          d = Buffer.concat(this._caughtData)\n        } else {\n          d = joinBufferData(this._caughtData)\n        }\n        r(d)\n        this._caughtData = []\n      })\n      this.once('error', (e) => {\n        if (e.stack.indexOf('\\n') == -1) {\n          wrap`${e}`\n          j(e)\n        } else {\n          const stack = cleanStack(e.stack)\n          e.stack = stack\n          if (proxyError) wrap`${e}`\n          j(e)\n        }\n      })\n      if (rs) {\n        pipeError(this, rs).pipe(this)\n      }\n    })\n  }\n  _write(chunk, encoding, callback) {\n    this._caughtData.push(chunk)\n    callback()\n  }\n  /**\n   * A promise which will resolve will all data when the stream finishes.\n   * @type {Promise<string|Buffer>}\n   */\n  get promise() {\n    return this._promise\n  }\n}\n\n/**\n * Collect data into a catchment, and return results when the stream finishes.\n * @param {stream.Readable} readable A readable stream to collect all data from. If an error occurs during reading of this stream, the promise will be rejected with it.\n * @param {_catchment.CollectOptions} options Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n * @param {boolean} [options.binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n * @param {boolean} [options.proxyError=false] Sets whether an error emitted by the stream with have its stack start at the line where the `collect` was called rather than inside of the stream. In other words, hides the implementation of the stream. Default `false`.\n * @example\n *\n * import { collect } from 'catchment'\n * import { createReadStream } from 'fs'\n *\n * const rs = createReadStream(path)\n * await collect(rs, { proxyError: true })\n */\nexport const collect = async (readable, options = {}) => {\n  const { promise } = new Catchment({\n    rs: readable,\n    ...options,\n    er: erotic(true),\n  })\n  const res = await promise\n  return res\n}\n\n/* typal types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_catchment.Options} Options Options to pass to the `Writable` super constructor, and others shown below.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _catchment.Options Options to pass to the `Writable` super constructor, and others shown below.\n * @prop {!stream.Readable} [rs] A readable stream to automatically pipe into the catchment. If an error occurs during reading of this stream, the catchment promise will be rejected with it.\n * @prop {boolean} [binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Readable} stream.Readable\n */\n\n/* typal types/collect.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_catchment.CollectOptions} CollectOptions Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _catchment.CollectOptions Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n * @prop {boolean} [binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n * @prop {boolean} [proxyError=false] Sets whether an error emitted by the stream with have its stack start at the line where the `collect` was called rather than inside of the stream. In other words, hides the implementation of the stream. Default `false`.\n */\n","import erte from 'erte'\nimport erotic from 'erotic'\n\nconst equal = (a, b) => {\n  if (a != b) {\n    const e = erte(`${a}`, `${b}`)\n    const msg = `${a} != ${b}`\n    const er = new Error(`${e}\\n${msg}`) //\n    throw er\n  }\n}\n\nconst assertString = (errorMessage, m) => {\n  equal(errorMessage, m)\n}\n\nconst assertRe = (actual, re) => {\n  const res = re.test(actual)\n  if (!res) {\n    throw new Error(`${actual} does not match regular expression ${re}`)\n  }\n}\n\nconst assertFn = async (actual, fn) => {\n  await fn(actual)\n}\n\nconst assert = async (prop, assertion) => {\n  if (assertion instanceof RegExp) {\n    assertRe(prop, assertion)\n  } else if (typeof assertion == 'function') {\n    await assertFn(prop, assertion)\n  } else if (assertion) {\n    assertString(prop, assertion)\n  }\n}\n\n/**\n * Assert that a function throws and check the thrown error properties.\n * @param {_assertThrows.Config} config Parameters to the `assert-throws` method.\n * @param {!Function} config.fn The function to test, either sync or async.\n * @param {*|!Array<*>} [config.args] The arguments or single argument to pass to the function.\n * @param {*} [config.context] The context in which to execute the function. Global context will be set by default.\n * @param {_assertThrows.Assertion} [config.message] A string, regex, or function to test the message.\n * @param {_assertThrows.Assertion} [config.code] A string, regex, or function to test the code.\n * @param {_assertThrows.Assertion} [config.stack] A string, regex, or function to test the stack.\n * @param {_assertThrows.Assertion} [config.prop] A string, regex, or function to test any other property of the error.\n * @param {Error} [config.error] An error to perform strict comparison against.\n * @example\n```\nawait throws({\n  fn: method,\n  args: ['test', true],\n  message: /An error occurred:/, // regex\n  code: 'ENOTEST',               // string\n  stack(stack) {                 // function\n    equal(stack.length, 2)\n  }\n})\n```\n */\nexport default async function assertThrows(config) {\n  if (!config) throw new Error('Config expected.')\n  const e = erotic(true)\n  const {\n    fn, args = [], context, error, ...props\n  } = config\n  if (typeof fn != 'function') throw new Error('Function expected.')\n  const arg = Array.isArray(args) ? args : [args]\n\n  try {\n    const thrownError = await wrap(fn, context, arg, error, props)\n    return thrownError\n  } catch (err) {\n    const er = e(err)\n    throw er\n  }\n}\n\nconst wrap = async (fn, context, args, error, props) => {\n  const shouldHaveThrownError = new Error()\n  try {\n    if (context) {\n      await fn.call(context, ...args)\n    } else {\n      await fn(...args)\n    }\n    throw shouldHaveThrownError\n  } catch (err) {\n    if (err === shouldHaveThrownError) {\n      const n = fn.name && fn.name !== 'fn' ? `${fn.name} ` : ''\n      throw new Error(`Function ${n}should have thrown.`)\n    }\n    if (error && error !== err) {\n      throw new Error(`${err} is not strict equal to ${error}.`)\n    }\n\n    await Object.keys(props).reduce(async (acc, k) => {\n      await acc\n      const assertion = props[k]\n      const actual = err[k]\n      await assert(actual, assertion)\n    }, {})\n\n    return err\n  }\n}\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_assertThrows.Assertion} Assertion An assertion to perform.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {!(string|RegExp|!Function)} _assertThrows.Assertion An assertion to perform.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_assertThrows.Config} Config Parameters to the `assert-throws` method.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _assertThrows.Config Parameters to the `assert-throws` method.\n * @prop {!Function} fn The function to test, either sync or async.\n * @prop {*|!Array<*>} [args] The arguments or single argument to pass to the function.\n * @prop {*} [context] The context in which to execute the function. Global context will be set by default.\n * @prop {_assertThrows.Assertion} [message] A string, regex, or function to test the message.\n * @prop {_assertThrows.Assertion} [code] A string, regex, or function to test the code.\n * @prop {_assertThrows.Assertion} [stack] A string, regex, or function to test the stack.\n * @prop {_assertThrows.Assertion} [prop] A string, regex, or function to test any other property of the error.\n * @prop {Error} [error] An error to perform strict comparison against.\n */\n","import { c } from 'erte'\n\nconst log = (t, ...args) => {\n  let j = -1\n  const s = t.replace(/%s/g, () => {\n    j++\n    return args[j]\n  })\n  return s\n}\n\n/**\n * Compare JS Objects With Color Difference.\n */\nexport default function differently(objectA, objectB) {\n  let level = 0\n\n  const write = (was, became = undefined) => {\n    const i = ' '.repeat(level * 2)\n    const b = became !== undefined ? c('+ ' + toString(became), 'green') : null\n    const w = was !== undefined ? c('- ' + toString(was), 'red') : null\n    const t = []\n    if (w) t.push(log('%s%s', i, w))\n    if (b) t.push(log('%s%s', i, b))\n    return t.join('\\n')\n  }\n  const writeCommon = (propName) => {\n    const i = ' '.repeat(level * 2)\n    return log('%s%s', i, propName)\n  }\n  const compare = (a, b) => {\n    if (a instanceof Date && b instanceof Date) {\n      if (!compareDates(a, b)) {\n        return write(a, b)\n      }\n      return ''\n    } else if (\n      (a instanceof Date && !(b instanceof Date)) ||\n      (!(a instanceof Date) && b instanceof Date) ||\n      (Array.isArray(a) && !Array.isArray(b)) ||\n      (!Array.isArray(a) && Array.isArray(b))\n    ) {\n      return write(a, b)\n    } else if (\n      (isPrimitive(a) && isPrimitive(b)) ||\n      (!isPrimitive(a) && isPrimitive(b)) ||\n      (isPrimitive(a) && !isPrimitive(b))\n    ) {\n      if (a != b) return write(a, b)\n      return ''\n    } else if (a.constructor && !b.constructor) {\n      return write(a.constructor.name, b)\n    } else if (!a.constructor && b.constructor) {\n      return write(a, b.constructor.name)\n    } else if (a.constructor && b.constructor) {\n      if (a.constructor.name != b.constructor.name) {\n        return write(a.constructor.name, b.constructor.name)\n      }\n      const valA = a.valueOf()\n      const valB = b.valueOf()\n      if (isPrimitive(valA) && isPrimitive(valB) && valA != valB) {\n        return write(valA, valB)\n      }\n    }\n    if (Array.isArray(a) && Array.isArray(b)) {\n      let j\n      const updated = a.map((valA, i) => {\n        j = i\n        const valB = b[i]\n        let ca = compare(valA, valB)\n        if (ca) ca = `${writeCommon(`[${i}]`)}\\n${ca}`\n        return ca\n      }).filter(Boolean)\n      const rest = b.slice(j + 1).map((valB, i) => {\n        return `${writeCommon(`[${j + i + 1}]`)}\\n${write(undefined, valB)}`\n      })\n      return [...updated, ...rest].join('\\n')\n    }\n    if (typeof a == 'object' && typeof b == 'object') {\n      const added = []\n      const removed = []\n      const common = []\n      Object.keys(a).forEach((k) => {\n        if (!(k in b)) removed.push(k)\n        else common.push(k)\n      })\n      Object.keys(b).forEach((k) => {\n        if (!(k in a)) added.push(k)\n      })\n      const R = removed.map(r => {\n        let s = toString(a[r])\n        // if (/^\\s+$/.test(s)) s = `\"${s}\"`\n        s = `: ${s}`\n        return write(`${r}${s}`)\n      })\n      const A = added.map(ad => write(undefined, `${ad}: ${toString(b[ad])}`))\n\n      const updated = common.map((k) => {\n        level++\n        const written = compare(a[k], b[k])\n        let u = ''\n        if (written) {\n          u += writeCommon(Array.isArray(a[k]) && Array.isArray(b[k]) ? `${k}.Array` : k)\n          u += '\\n' + written\n        }\n        level--\n        return u\n      }).filter(Boolean)\n\n      const RA = [...R, ...A, ...updated].join('\\n')\n\n      return RA\n    }\n    console.error('Could not compare two values: %s %s. Please file a bug with differently.', a, b)\n  }\n\n  const s = compare(objectA, objectB)\n\n  return s\n}\n\nconst isPrimitive = a => {\n  if (a === null) return true\n  return ['string', 'number', 'boolean',\n    'symbol', 'null', 'undefined'].includes(typeof a)\n}\n\nconst toString = (p) => {\n  if (Array.isArray(p)) return `Array[${p.toString()}]`\n  const hasToString = p && p.toString\n  const s = hasToString ? p.toString() : `${p}`\n  // if (p && p.constructor && p.constructor.name)\n    // return `${p.constructor.name}.${s}`\n  return s\n}\n\n/**\n * @param {!Date} a\n * @param {!Date} b\n */\nconst compareDates = (a, b) => {\n  if (a.getTime() != b.getTime()) return false\n}","import { deepStrictEqual } from 'assert'\nimport differently from 'differently'\n\n/**\n * The Deep Equal Assertion With Color.\n * @param {?} actual\n * @param {?} expected\n * @param {string} [message]\n */\nexport default function deepEqual(actual, expected, message) {\n  try {\n    deepStrictEqual(actual, expected, message)\n  } catch (err) {\n    const s = differently(expected, actual)\n    err.message = [err.message, s].filter(Boolean).join('\\n')\n    throw err\n  }\n}\n\n","export default child_process\nexport const {\n  ChildProcess,\n  exec,\n  execFile,\n  execFileSync,\n  execSync,\n  fork,\n  spawn,\n  spawnSync,\n} = child_process","import { spawn, fork as forkCp } from 'child_process'\nimport { collect } from 'catchment'\n\n/**\n * @param {!child_process.ChildProcess} proc\n * @returns {!Promise<_spawncommand.PromiseResult>}\n */\nconst getPromise = async (proc) => {\n  const [code, stdout, stderr] = await Promise.all([\n    new Promise((resolve, reject) => {\n      proc.on('error', reject)\n        .on('exit', (code) => {\n          resolve(code)\n        })\n    }),\n    proc.stdout ? collect(proc.stdout) : undefined,\n    proc.stderr ? collect(proc.stderr) : undefined,\n  ])\n  return {\n    code,\n    stdout,\n    stderr,\n  }\n}\n\n/**\n * Spawns a new process using the `command` and returns an instance of a ChildProcess, extended to have a `promise` property which is resolved when the process exits. The resolved value is an object with `stdout`, `stderr` and `code` properties.\n * @param {string} command The command to run.\n * @param {!Array<string>} [args] List of string arguments.\n * @param {!child_process.SpawnOptions} [options] Options used to spawn.\n */\nexport default function spawnCommand(command, args, options) {\n  if (!command) throw new Error('Please specify a command to spawn.')\n  const proc = /** @type {!_spawncommand.ChildProcessWithPromise} */ (spawn(command, args, options))\n\n  const promise = getPromise(proc)\n  proc.promise = promise\n  /** @suppress {checkTypes} */\n  proc.spawnCommand = proc['spawnargs'].join(' ')\n  return proc\n}\n\n/**\n * Forks a process and assign a `promise` property to it, resolved with `stderr`, `stdout` and `code` properties on exit.\n * @param {string} mod The module to run in the child.\n * @param {!Array<string>} [args] List of string arguments.\n * @param {!child_process.ForkOptions} [options] Options to fork the process with.\n */\nexport function fork(mod, args, options) {\n  if (!mod) throw new Error('Please specify a module to fork')\n  const proc = /** @type {!_spawncommand.ChildProcessWithPromise} */ (forkCp(mod, args, options))\n\n  const promise = getPromise(proc)\n  proc.promise = promise\n  /** @suppress {checkTypes} */\n  proc.spawnCommand = proc['spawnargs'].join(' ')\n  return proc\n}\n\n/* typal types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_spawncommand.PromiseResult} PromiseResult\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _spawncommand.PromiseResult\n * @prop {string} stdout The accumulated result of the `stdout` stream.\n * @prop {string} stderr The accumulated result of the `stderr` stream.\n * @prop {number} code The code with which the process exited.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('child_process').SpawnOptions} child_process.SpawnOptions\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('child_process').ForkOptions} child_process.ForkOptions\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('child_process').ChildProcess} child_process.ChildProcess\n */\n\n/* documentary types/cp.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_spawncommand.ChildProcessWithPromise} ChildProcessWithPromise A child process with an extra `promise` property.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {child_process.ChildProcess & _spawncommand.$ChildProcessWithPromise} _spawncommand.ChildProcessWithPromise A child process with an extra `promise` property.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _spawncommand.$ChildProcessWithPromise A child process with an extra `promise` property.\n * @prop {!Promise<!_spawncommand.PromiseResult>} promise A promise resolved when the process exits.\n * @prop {string} spawnCommand The spawn arguments joined by whitespace.\n */\n","/**\n * Write data to the `writable` when data from the `readable` matches the regexp.\n * @param {!stream.Readable} readable A readable stream to detect data on.\n * @param {!stream.Writable} stdin A writable stream to pass answers to.\n * @param {!Array<!Array<(!RegExp|string)>>} inputs A serial collection of answers. Each answer will be ended with a `\\n` character. For example, `[[/question/, 'answer'], [/question2/, 'answer2]]`.\n * @param {stream.Writable} [log] A stream to which to write both data from readable, and the passed answer.\n */\nconst forkFeed = (readable, stdin, inputs = [], log = null) => {\n  if (log) readable.on('data', d => log.write(d))\n\n  let [a, ...rest] = inputs\n  if (!a) return\n\n  const handler = (d) => {\n    const [regexp, answer] = a\n    if (!regexp.test(d)) return\n\n    const an = `${answer}\\n`\n    if (log) log.write(an)\n\n    stdin.write(an)\n    ;([a, ...rest] = rest)\n    if (!a) readable.removeListener('data', handler)\n  }\n  readable.on('data', handler)\n}\n\nexport default forkFeed\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Writable} stream.Writable\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Readable} stream.Readable\n */\n","import deepEqual from '@zoroaster/deep-equal'\r\nimport erte from 'erte'\r\nimport { strictEqual } from 'assert'\r\n\r\nexport const assertExpected = (result, expected) => {\r\n  try {\r\n    strictEqual(result, expected)\r\n  } catch (err) {\r\n    const e = erte(expected, result)\r\n    console.log(e) // eslint-disable-line no-console\r\n    throw err\r\n  }\r\n}\r\n\r\n/**\r\n * @param {string|_contextTesting.ForkConfig} forkConfig Parameters for forking.\r\n * @param {!Array<string>} args The arguments to the fork\r\n * @param {!Array<_contextTesting.Context>} contexts The array of contexts.\r\n * @param {*} props The props found in the mask.\r\n */\r\nexport const getForkArguments = async (forkConfig, args = [], contexts = [], props = {}) => {\r\n  const stdioOpts = /** @type {!child_process.ForkOptions} */ ({\r\n    stdio: 'pipe',\r\n    execArgv: [],\r\n  })\r\n  if (typeof forkConfig == 'string') {\r\n    return {\r\n      mod: forkConfig,\r\n      args,\r\n      options: stdioOpts,\r\n    }\r\n  }\r\n  const {\r\n    module: mod,\r\n    getArgs,\r\n    options,\r\n    getOptions,\r\n  } = forkConfig\r\n  const a = getArgs ? await getArgs.call(props, args, ...contexts) : args\r\n  let opt = stdioOpts\r\n  if (options) {\r\n    opt = {\r\n      ...stdioOpts,\r\n      ...options,\r\n    }\r\n  } else if (getOptions) {\r\n    const o = await getOptions.call(props, ...contexts)\r\n    opt = {\r\n      ...stdioOpts,\r\n      ...o,\r\n    }\r\n  }\r\n  return {\r\n    mod,\r\n    args: a,\r\n    options: opt,\r\n  }\r\n}\r\n\r\n/**\r\n * Assert on the streamed fork output.\r\n * @param {string} actual The actual output of the fork.\r\n * @param {string|!Object} expected The expected value of a property.\r\n * @param {string} prop The name of the property. \r\n */\r\nexport const assertForkOutput = (actual, expected, prop) => {\r\n  try {\r\n    if (typeof expected == 'string') {\r\n      assertExpected(actual, expected)\r\n    } else if (expected) {\r\n      const a = JSON.parse(actual)\r\n      deepEqual(a, expected)\r\n    }\r\n  } catch (err) {\r\n    // set 'property' to interactively update masks on fail via @zoroaster/mask\r\n    if (prop) err['property'] = prop\r\n    throw err\r\n  }\r\n}\r\n\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('child_process').ForkOptions} child_process.ForkOptions\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('../../types').Context} _contextTesting.Context\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('../../types').ForkConfig} _contextTesting.ForkConfig\r\n */\r\n","import mismatch from 'mismatch'\r\n\r\n/**\r\n * Return shell arguments from a string.\r\n * @param {string} input\r\n */\r\nconst getArgs = (input) => {\r\n  const res = mismatch(/(['\"])?([\\s\\S]+?)\\1(\\s+|$)/g, input, ['q', 'a'])\r\n    .map(({ 'a': a }) => a)\r\n  return res\r\n}\r\n\r\nexport default getArgs","import { fork } from 'spawncommand'\r\nimport forkFeed from 'forkfeed'\r\nimport Catchment from 'catchment'\r\nimport { PassThrough } from 'stream'\r\nimport { EOL } from 'os'\r\nimport { getForkArguments, assertForkOutput } from './lib'\r\nimport getArgs from './lib/get-args'\r\n\r\n/**\r\n * @type {_contextTesting.fork}\r\n */\r\nconst run = async (config) => {\r\n  const {\r\n    forkConfig,\r\n    input,\r\n    props = {},\r\n    contexts = [],\r\n  } = config\r\n  const a = input ? getArgs(input) : []\r\n  const {\r\n    mod, args, options,\r\n  } = await getForkArguments(forkConfig, a, contexts, {\r\n    ...props,\r\n    input,\r\n  })\r\n  const { promise, stdout, stdin, stderr } = fork(mod, args, options)\r\n\r\n  const { includeAnswers = true, log, inputs, stderrInputs, stripAnsi = true, \r\n    preprocess, \r\n    normaliseOutputs = false, // will be true next version\r\n  } = forkConfig\r\n\r\n  const stdoutLog = new PassThrough()\r\n  const stderrLog = new PassThrough()\r\n\r\n  if (log === true) {\r\n    stdoutLog.pipe(process.stdout)\r\n    stderrLog.pipe(process.stderr)\r\n  } else if (log) {\r\n    log.stdout && stdoutLog.pipe(log.stdout)\r\n    log.stderr && stderrLog.pipe(log.stderr)\r\n  }\r\n\r\n  const needsStdoutAnswers = includeAnswers && inputs\r\n  const needsStderrAnswers = includeAnswers && stderrInputs\r\n\r\n  let co, ce\r\n  if (needsStdoutAnswers) co = new Catchment({ rs: stdoutLog })\r\n  if (needsStderrAnswers) ce = new Catchment({ rs: stderrLog })\r\n\r\n  /**\r\n   * @suppress {checkTypes}\r\n   * @type {stream.Writable}\r\n   */\r\n  const _stdoutLog = stdoutLog\r\n  /**\r\n   * @suppress {checkTypes}\r\n   * @type {stream.Writable}\r\n   */\r\n  const _stderrLog = stderrLog\r\n  forkFeed(stdout, stdin, inputs, _stdoutLog)\r\n  forkFeed(stderr, stdin, stderrInputs, _stderrLog)\r\n\r\n  const res = await promise\r\n\r\n  // override process's outputs with outputs with answers\r\n  if (needsStdoutAnswers) {\r\n    co.end(); const stdoutWithAnswers = await co.promise\r\n    Object.assign(res, {\r\n      stdout: stdoutWithAnswers,\r\n    })\r\n  }\r\n  if (needsStderrAnswers) {\r\n    ce.end(); const stderrWithAnswers = await ce.promise\r\n    Object.assign(res, {\r\n      stderr: stderrWithAnswers,\r\n    })\r\n  }\r\n\r\n  assertFork(res, props, stripAnsi, preprocess, normaliseOutputs)\r\n  return res\r\n}\r\n\r\nconst assertFork = ({ code, stdout, stderr }, props, stripAnsi, preprocess, normaliseOutputs) => {\r\n  let stdoutPre, stderrPre\r\n  if (typeof preprocess == 'object') {\r\n    ({ stdout: stdoutPre, stderr: stderrPre } = preprocess)\r\n  } else if (typeof preprocess == 'function') {\r\n    stdoutPre = stderrPre = preprocess\r\n  }\r\n  stdout = stdout.replace(/\\r?\\n$/, '')\r\n  stderr = stderr.replace(/\\r?\\n$/, '')\r\n  const o = stripAnsi ? stdout.replace(/\\033\\[.*?m/g, '') : stdout\r\n  const e = stripAnsi ? stderr.replace(/\\033\\[.*?m/g, '') : stderr\r\n  const no = normaliseOutputs ? normaliseWin(o) : o\r\n  const ne = normaliseOutputs ? normaliseWin(e) : e\r\n  const op = stdoutPre ? stdoutPre(no) : no\r\n  const ep = stderrPre ? stderrPre(ne) : ne\r\n  assertForkOutput(op, props.stdout, 'stdout')\r\n  assertForkOutput(ep, props.stderr, 'stderr')\r\n  if (props.code && code != props.code) {\r\n    const err =\r\n      new Error(`Fork exited with code ${code} != ${props.code}`)\r\n    err.property = 'code'\r\n    throw err\r\n  }\r\n  return { stdout: op, stderr: ep }\r\n}\r\n\r\n/**\r\n * Normalises output for windows because of console.log so that\r\n * new lines are consistent.\r\n * @param {string} s The input string.\r\n */\r\nfunction normaliseWin(s) {\r\n  if (process.platform != 'win32') return s\r\n  return s.replace(/([^\\r])\\n/g, `$1${EOL}`)\r\n}\r\n\r\nexport default run\r\n\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('../types').fork} _contextTesting.fork\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('stream').Readable} stream.Readable\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('stream').Writable} stream.Writable\r\n */","import { EOL } from 'os'\r\nimport { collect } from 'catchment'\r\nimport throws from 'assert-throws'\r\nimport deepEqual from '@zoroaster/deep-equal'\r\nimport fork from '@zoroaster/fork'\r\nimport { assertExpected } from '../mask'\r\n\r\n/**\r\n * Create a new test.\r\n * @param {!_contextTesting.MaskConfig} params\r\n * @param {string} params.input\r\n * @param {string} params.error\r\n * @param {string} params.expected\r\n * @param {*} params.props\r\n */\r\nconst makeTest = (params) => {\r\n  const {\r\n    input, error, expected, props,\r\n    getThrowsConfig, getTransform, getResults,\r\n    assertResults, mapActual, getReadable, fork: forkConfig,\r\n    debugLog,\r\n  } = params\r\n  const test = async (...contexts) => {\r\n    const cntx = /** @type {_contextTesting.MaskContext} */ ({ input, ...props })\r\n    let results\r\n    if (error) {\r\n      if (!getThrowsConfig)\r\n        throw new Error('No \"getThrowsConfig\" function is given.')\r\n      const throwsConfig = getThrowsConfig.call(cntx, ...contexts)\r\n      await assertError(throwsConfig, error)\r\n      return\r\n    } else if (getTransform) {\r\n      assertHasExpected(expected)\r\n      const rs = await getTransform.call(cntx, ...contexts)\r\n      rs.end(input)\r\n      results = await collect(rs)\r\n    } else if (getReadable) {\r\n      assertHasExpected(expected)\r\n      const rs = await getReadable.call(cntx, ...contexts)\r\n      results = await collect(rs)\r\n    } else if (forkConfig) {\r\n      if (cntx.inputs)\r\n        forkConfig.inputs = getInputsFromProps(cntx.inputs)\r\n\r\n      const r = await fork({\r\n        forkConfig,\r\n        input,\r\n        props,\r\n        contexts,\r\n      })\r\n\r\n      results = getResults ? await getResults.call(cntx, ...contexts) : r\r\n    } else if (!getResults) {\r\n      throw new Error('Nothing was tested.')\r\n    } else {\r\n      results = await getResults.call(cntx, ...contexts)\r\n    }\r\n\r\n    if (expected !== undefined) {\r\n      const actual = mapActual(results)\r\n      if (typeof expected != 'string') { // already parsed\r\n        try {\r\n          deepEqual(actual, expected)\r\n        } catch (err) {\r\n          err['property'] = 'expected'\r\n          throw err\r\n        }\r\n      } else if ((typeof actual).toLowerCase() != 'string') {\r\n        throw new Error('The actual result is not an a string. Use \"mapActual\" function to map to a string result, or add \"expected\" to \"jsonProps\" or \"jsProps\".')\r\n      } else {\r\n        assertExpected(actual, expected, debugLog)\r\n      }\r\n    }\r\n    if (assertResults) {\r\n      await assertResults.call(cntx, results, props)\r\n    }\r\n  }\r\n  return test\r\n}\r\n\r\nconst assertHasExpected = (expected) => {\r\n  if (expected === undefined) throw new Error('No expected output was given.')\r\n}\r\n\r\nconst getInputsFromProps = (s) => {\r\n  const res = s.split(EOL).map(i => {\r\n    const [q, a] = i.split(/: +/)\r\n    const re = new RegExp(q)\r\n    return [re, a]\r\n  })\r\n  return res\r\n}\r\n\r\nconst assertError = async (throwsConfig, error) => {\r\n  await throws(/** @type {_assertThrows.Config} */ ({\r\n    ...throwsConfig,\r\n    message: error,\r\n  }))\r\n}\r\n\r\nexport default makeTest\r\n\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('../../types').MaskConfig} _contextTesting.MaskConfig\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('../../types').MaskContext} _contextTesting.MaskContext\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('../../types').MaskForkConfig} _contextTesting.MaskForkConfig\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('assert-throws').Config} _assertThrows.Config\r\n */\r\n","import { c as color } from 'erte'\r\nimport { readdirSync, lstatSync } from 'fs'\r\nimport { join, dirname, basename } from 'path'\r\nimport getTests from './mask'\r\nimport makeTest from './lib/make-test'\r\nimport { parseProps } from './lib'\r\n\r\n/**\r\n * @type {_contextTesting.makeTestSuite}\r\n */\r\nfunction makeTestSuite(path, conf, _content = null) {\r\n  if (Array.isArray(path)) {\r\n    const ts = path.reduce((acc, p) => {\r\n      const nn = basename(replaceFilename(p))\r\n      const its = makeTestSuite(p, conf, _content)\r\n      Object.assign(acc, { [nn]: its })\r\n      return acc\r\n    }, {})\r\n    return ts\r\n  }\r\n  let pathStat\r\n  const isFocused = path.startsWith('!')\r\n  let realPath = isFocused ? path.replace(/^!/, '') : path\r\n  try {\r\n    pathStat = lstatSync(realPath)\r\n  } catch (err) {\r\n    if (err.code != 'ENOENT') {\r\n      throw err\r\n    }\r\n    realPath = resolve(realPath, _content)\r\n    pathStat = lstatSync(realPath)\r\n  }\r\n  let ts\r\n  if (pathStat.isFile()) {\r\n    ts = makeATestSuite(realPath, conf)\r\n  } else if (pathStat.isDirectory()) {\r\n    const content = readdirSync(realPath)\r\n    ts = content.reduce((acc, node) => {\r\n      const newPath = join(realPath, node)\r\n      const nn = replaceFilename(node)\r\n      return {\r\n        ...acc,\r\n        [nn]: makeTestSuite(newPath, conf, content),\r\n      }\r\n    }, {})\r\n  }\r\n  if (isFocused) return { [path]: ts }\r\n  return ts\r\n}\r\n\r\nexport default makeTestSuite\r\n\r\nconst replaceFilename = (filename) => {\r\n  return filename.replace(/\\.\\w+?$/, '')\r\n}\r\n\r\nconst resolve = (path, content) => {\r\n  const dir = dirname(path)\r\n  const files = content || readdirSync(dir)\r\n  const matchingFiles = files.filter((f) => {\r\n    return f.startsWith(`${basename(path)}.`)\r\n  })\r\n  if (matchingFiles.length > 1) {\r\n    throw new Error(`Could not resolve the result path ${path}, possible files: ${matchingFiles.join(', ')}.`)\r\n  } else if (matchingFiles.length) {\r\n    path = join(dir, matchingFiles[0])\r\n  } else {\r\n    throw new Error(`Could not resolve the result path ${path}.`)\r\n  }\r\n  return path\r\n}\r\n\r\n// The `expected` property of the mask will be compared against the actual value returned by the `getActual` function. To test for the correct error message, the `error` property will be tested using `assert-throws` configuration returned by `getThrowsConfig` function. Any additional tests can be performed with `customTest` function, which will receive any additional properties extracted from the mask using `customProps` and `jsonProps`. The JSON properties will be parsed into an object.\r\n\r\n/**\r\n * @param {string} maskPath Path to the mask.\r\n */\r\nconst makeATestSuite = (maskPath, conf) => {\r\n  /** @type {!_contextTesting.MaskConfig} */\r\n  const c = conf\r\n  if (!c) throw new Error('No configuration is given. A config should at least contain either a \"getThrowsConfig\", \"getResults\", \"getTransform\" or \"getReadable\" functions.')\r\n  const {\r\n    context,\r\n    persistentContext,\r\n    getResults,\r\n    getTransform,\r\n    getReadable,\r\n    getThrowsConfig,\r\n    mapActual = a => a,\r\n    assertResults,\r\n    jsonProps = [],\r\n    jsProps = [],\r\n    splitRe,\r\n    fork: forkConfig,\r\n    propEndRe,\r\n    propStartRe,\r\n    debugLog,\r\n  } = c\r\n  const tests = getTests({\r\n    path: maskPath, splitRe, propEndRe, propStartRe, jsonProps })\r\n\r\n  const t = tests.reduce((acc, {\r\n    name, 'error': error, onError, ...rest\r\n  }) => {\r\n    let setupError\r\n    let props\r\n    let expected\r\n    let input\r\n    if (name in acc)\r\n      setupError = `Repeated use of the test name \"${name}\".`\r\n    try {\r\n      ({ 'expected': expected, 'input': input, ...props }\r\n        = parseProps(rest, jsonProps, jsProps))\r\n    } catch ({ message }) {\r\n      setupError = message\r\n    }\r\n\r\n    let test\r\n    if (setupError) {\r\n      test = () => { throw new Error(setupError) }\r\n    } else {\r\n      test = makeTest({\r\n        input, error, getThrowsConfig, getTransform, getReadable, getResults, expected,\r\n        assertResults, props, mapActual, fork: forkConfig, debugLog,\r\n      })\r\n    }\r\n\r\n    acc[name] = async (...args) => {\r\n      try {\r\n        await test(...args)\r\n      } catch (err) {\r\n        if (process.env['DEBUG']) console.log(color(err.stack, 'red'))\r\n        await onError(err) // show location in the error stack. TODO: keep mask line\r\n      }\r\n    }\r\n    return acc\r\n  }, {\r\n    ...(context ? { 'context': context }: {}),\r\n    ...(persistentContext ? { 'persistentContext': persistentContext }: {}),\r\n  })\r\n  return t\r\n}\r\n\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('..').MaskConfig} _contextTesting.MaskConfig\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {import('..')} _contextTesting.makeTestSuite\r\n */","import '../types/externs'\r\nimport _makeTestSuite from './'\r\n\r\nmodule.exports = _makeTestSuite"],
"names":["pushComponent","components","added","removed","last","length","count","push","extractCommon","basePath","newString","oldString","diagonalPath","newLen","oldLen","newPos","oldPos","commonCount","equals","removeEmpty","array","ret","i","diff","Diff","split","editLength","maxEditLength","bestPath","value","join","addPath","removePath","undefined","canAdd","canRemove","slice","self","buildValues","left","right","chars","componentPos","componentLen","component","tmp","map","v","oldValue","lastComponent","pop","colors","backgroundColors","c","string","color","cc","b","erte","source","target","d","m","s","p","t","replace","lstatSync","fs","readFileSync","readdirSync","writeFileSync","basename","path","dirname","deepStrictEqual","assert","equal","strictEqual","mismatch","re","keys","addPositions","match","args","position","start","o","reduce","acc","capturedGroup","key","createInterface","readline","createTimeout","desc","timeout","cb","setTimeout","err","Error","message","stack","makeTimeoutPromise","to","promise","Promise","_","reject","createPromiseWithTimeout","toPromise","race","clearTimeout","ask","question","options","password","output","process","stdout","input","stdin","rest","rl","includes","write","repeat","r","promto","tryPromise","res","close","askQuestions","questions","Object","accRes","text","endsWith","gotDefaultValue","defaultValue","getDefault","dv","gtd","answer","a","validation","postProcess","askSingle","confirm","defaultYes","Q","hasQ","realText","splitWithPositions","tt","separator","arr","next","nextPosition","parseProps","props","jsonProps","jsProps","parsedRest","ac","k","val","JSON","parse","eval","EOL","os","homedir","getTests","conf","propStartRe","propEndRe","splitRe","resultFile","mi","exec","preamble","index","mm","lastIndex","tests","filter","test","name","total","body","splitWithRe","RegExp","bodyStartsAt","indexOf","offset","positions","expected","foundProps","preValue","newLine","lines","lengthDifference","onError","error","lineRe","lineNumber","current","property","actual","handleUpdate","act","stringify","newFile","console","shouldUpdate","log","testsWithOnError","boundOnError","bind","nl","search","substr","first","second","assertExpected","result","e","PassThrough","stream","Writable","getStackSegment","from","oneLine","splitStack","item","items","getEntryStack","transparent","stackSegment","getCallerFromArguments","caller","extractPathRegex","pathRegex","homeDir","cleanStack","pretty","ignoredModules","j","x","pathMatches","trim","p1","makeCallback","entryCaller","entryStack","shadow","messageOrError","arguments","errorStack","calleeStackLine","isError","stackMessage","stackHeading","assign","properties","erotic","pipeError","streamA","streamB","once","emit","Catchment","binary","rs","opts","er","proxyError","wrap","_caughtData","_promise","on","Buffer","concat","pipe","chunk","encoding","callback","collect","readable","assertFn","fn","prop","assertion","msg","assertThrows","config","context","arg","Array","isArray","thrownError","shouldHaveThrownError","call","n","differently","objectA","objectB","level","was","became","toString","w","writeCommon","propName","compare","Date","getTime","isPrimitive","constructor","valA","valueOf","valB","updated","ca","Boolean","common","forEach","R","A","ad","written","u","RA","deepEqual","fork","child_process","getPromise","proc","code","stderr","all","resolve","forkFeed","inputs","handler","regexp","an","removeListener","getForkArguments","forkConfig","contexts","stdioOpts","stdio","execArgv","mod","getArgs","getOptions","opt","assertForkOutput","run","forkCp","spawnCommand","includeAnswers","stderrInputs","stripAnsi","preprocess","normaliseOutputs","stdoutLog","stderrLog","needsStdoutAnswers","needsStderrAnswers","co","ce","end","stdoutWithAnswers","stderrWithAnswers","assertFork","stdoutPre","stderrPre","no","normaliseWin","ne","op","ep","platform","makeTest","params","getThrowsConfig","getTransform","getResults","assertResults","mapActual","getReadable","debugLog","cntx","throwsConfig","assertError","assertHasExpected","results","getInputsFromProps","toLowerCase","q","throws","makeTestSuite","_content","ts","nn","its","pathStat","isFocused","startsWith","realPath","isFile","makeATestSuite","isDirectory","content","node","newPath","dir","matchingFiles","f","maskPath","persistentContext","setupError","env","module","exports"]
}
